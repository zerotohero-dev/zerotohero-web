<!doctype html><html dir=auto lang=en><head><meta charset=utf-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content="index, follow" name=robots><title>Shamir's Secret Sharing Scheme with SPIFFE and SPIKE</title><meta content="keyword1, keyword2, keyword3" name=keywords><meta name=description><meta content="Volkan Özçelik" name=author><link href=https://zerotohero.dev/spire/spike/shamir-secrets-sharing/ rel=canonical><link href=https://zerotohero.dev/css/includes/scroll-bar.css rel=stylesheet><link href=https://zerotohero.dev/css/styles.css rel=stylesheet><link href=https://zerotohero.dev/css/override.css rel=stylesheet><link href=https://zerotohero.dev/atom.xml rel=alternate title=RSS type=application/atom+xml><noscript><style>#theme-toggle,.top-link{display:none}</style> <style>@media (prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:#dadadb;--secondary:#9b9c9d;--tertiary:#414244;--content:#c4c4c5;--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><body id=top><script>if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }</script><script src=https://player.vimeo.com/api/player.js></script><header class=header><nav class=nav><div class=logo><a title="Zero to Hero (Alt + H)" accesskey=h href=https://zerotohero.dev> <svg viewbox="-0.5 -0.5 32 32" height=32 id=High-Voltage--Streamline-Kawaii-Emoji style=position:relative;top:2px;left:4px width=32 xmlns=http://www.w3.org/2000/svg><desc>High Voltage Streamline Emoji: https://streamlinehq.com</desc><path d="M16.244 18.21002a56.048 56.048 0 0 1 -8.1313 -0.8853599999999999 3.3480000000000003 3.3480000000000003 0 0 1 -2.3374 -4.7802C6.500699999999999 11.097999999999999 16.04994 3.35854 21.79548 1.2059a1.14328 1.14328 0 0 1 1.36772 1.68392c-1.2183 1.8599999999999999 -3.5340000000000003 4.0641 -7.88702 8.56716 1.98772 0.124 4.207319999999999 -0.093 6.55216 -0.07688a3.66172 3.66172 0 0 1 3.0534999999999997 1.3813600000000001c0.6975 0.9734 0.97898 2.33058 0.32674000000000003 3.3356 -1.54504 2.37894 -9.10284 9.4054 -13.52468 12.80362 -1.5741800000000001 1.2096200000000001 -2.7565199999999996 1.27596 -3.41 0.26226 -0.39742 -0.6169 0.18166 -1.32618 0.5251399999999999 -1.8258999999999999C10.185979999999999 25.320800000000002 16.182000000000002 18.20754 16.244 18.21002z" fill=#ffe500 stroke-width=1></path><path d="M24.881839999999997 12.76146a3.66172 3.66172 0 0 0 -3.0534999999999997 -1.3813600000000001 52.95544 52.95544 0 0 0 -1.9734599999999998 0.03038 3.472 3.472 0 0 1 2.54696 1.3509799999999998c0.6975 0.9734 0.9796 2.33058 0.32674000000000003 3.3356 -1.5444200000000001 2.37894 -9.10284 9.40478 -13.52468 12.80362a6.66996 6.66996 0 0 1 -0.744 0.496c0.682 0.75144 1.78498 0.6107 3.2209000000000003 -0.496 4.424939999999999 -3.3988400000000003 11.98336 -10.42468 13.52778 -12.80362 0.65286 -1.00502 0.37076 -2.3622 -0.32674000000000003 -3.3356zM20.6832 2.88982c-1.16498 1.77816 -3.3368399999999996 3.87314 -7.33026 7.9918000000000005a0.35773999999999995 0.35773999999999995 0 0 0 0.248 0.60698c0.65596 0.01302 1.33486 0 2.0292600000000003 -0.02294 -0.11656 -0.00496 -0.23994000000000001 0 -0.35525999999999996 -0.00868 4.34 -4.495 6.66066 -6.700340000000001 7.88082 -8.556000000000001a1.1457600000000001 1.1457600000000001 0 0 0 -1.35904 -1.69446c-0.3565 0.1333 -0.7285 0.28892 -1.11104 0.46252a1.09802 1.09802 0 0 1 -0.00248 1.22078z" fill=#f2c100 stroke-width=1></path><path d="M16.244 18.21002a56.048 56.048 0 0 1 -8.1313 -0.8853599999999999 3.3480000000000003 3.3480000000000003 0 0 1 -2.3374 -4.7802C6.500699999999999 11.097999999999999 16.04994 3.35854 21.79548 1.2059a1.14328 1.14328 0 0 1 1.36772 1.68392c-1.2183 1.8599999999999999 -3.5340000000000003 4.0641 -7.88702 8.56716 1.98772 0.124 4.207319999999999 -0.093 6.55216 -0.07688a3.66172 3.66172 0 0 1 3.0534999999999997 1.3813600000000001c0.6975 0.9734 0.97898 2.33058 0.32674000000000003 3.3356 -1.54504 2.37894 -9.10284 9.4054 -13.52468 12.80362 -1.5741800000000001 1.2096200000000001 -2.7565199999999996 1.27596 -3.41 0.26226 -0.39742 -0.6169 0.18166 -1.32618 0.5251399999999999 -1.8258999999999999C10.185979999999999 25.320800000000002 16.182000000000002 18.20754 16.244 18.21002z" fill=none stroke=#45413c stroke-linecap=round stroke-linejoin=round stroke-width=1></path></svg> Zero to Hero </a><div class=logo-switches><button title="(Alt + T)" accesskey=t id=theme-toggle><svg viewbox="0 0 24 24" fill=none height=18 id=moon stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> <svg viewbox="0 0 24 24" fill=none height=18 id=sun stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg></button><ul class=lang-switch><li></ul></div></div><ul id=menu><li><a href=/about title=About> <span>About</span> </a><li><a href=/archive title=Archive> <span>Archive</span> </a><li><a href=/tags title=Tags> <span>Tags</span> </a><li><a title="Geyik TV" href=https://zerotohero.tv> <span>Geyik TV</span> <svg viewbox="0 0 24 24" fill=none height=12 shape-rendering=geometricPrecision stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2.5 width=12><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></svg> </a><li><a title="Vadideki Geyik" href=https://vadidekigeyik.com> <span>Vadideki Geyik</span> <svg viewbox="0 0 24 24" fill=none height=12 shape-rendering=geometricPrecision stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2.5 width=12><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></svg> </a><li><a href=https://discord.gg/kampus title=kamp.us> <span>kamp.us</span> <svg viewbox="0 0 24 24" fill=none height=12 shape-rendering=geometricPrecision stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2.5 width=12><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></svg> </a><li><a href=https://github.com/spiffe/spike title=SPIKE> <span>SPIKE</span> <svg viewbox="0 0 24 24" fill=none height=12 shape-rendering=geometricPrecision stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2.5 width=12><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></svg> </a><li><a href=https://github.com/vmware-tanzu/secrets-manager title=VSecM> <span>VSecM</span> <svg viewbox="0 0 24 24" fill=none height=12 shape-rendering=geometricPrecision stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2.5 width=12><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></svg> </a></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zerotohero.dev>Home</a> »  <a href=https://zerotohero.dev/>Posts</a> »  <a href=https://zerotohero.dev/spire/spike/shamir-secrets-sharing/>Shamir's Secret Sharing Scheme with SPIFFE and SPIKE</a></div><h1 class=post-title>Shamir's Secret Sharing Scheme with SPIFFE and SPIKE</h1><div class=post-meta><span title="2024-12-28 00:00:00 +0000">2024-12-28</span> · 15 min · Volkan Özçelik</div></header><div class=toc><details><summary title="(Alt + C)" accesskey=c><span class=details>Table of Contents</span></summary> <div class=inner><ul><li><a aria-label=Introduction href=#introduction>Introduction</a><li><a aria-label="A Video is a Worth a Million Words" href=#a-video-is-a-worth-a-million-words>A Video is a Worth a Million Words</a><li><a aria-label="Keeping the Root Key Secret" href=#keeping-the-root-key-secret>Keeping the Root Key Secret</a><li><a aria-label="Introducing Shamir’s Secret Sharing" href=#introducing-shamir-s-secret-sharing>Introducing Shamir’s Secret Sharing</a><li><a aria-label="SPIKE Architecture: A Brief Overview" href=#spike-architecture-a-brief-overview>SPIKE Architecture: A Brief Overview</a><li><a aria-label="High-Level Design" href=#high-level-design>High-Level Design</a> <ul><li><a aria-label="Starting SPIKE Keepers and SPIKE Nexus" href=#starting-spike-keepers-and-spike-nexus>Starting SPIKE Keepers and SPIKE Nexus</a><li><a aria-label="Initial Share Generation (the top of the diagram)" href=#initial-share-generation-the-top-of-the-diagram>Initial Share Generation (the top of the diagram)</a><li><a aria-label="Root Key Generation (middle-left)" href=#root-key-generation-middle-left>Root Key Generation (middle-left)</a><li><a aria-label="Shamir Secret Sharing" href=#shamir-secret-sharing>Shamir Secret Sharing</a><li><a aria-label="SPIKE Nexus Bootstrapping (bottom)" href=#spike-nexus-bootstrapping-bottom>SPIKE Nexus Bootstrapping (bottom)</a></ul><li><a aria-label="The SPIKE Keeper Workflow" href=#the-spike-keeper-workflow>The SPIKE Keeper Workflow</a> <ul><li><a aria-label=Initialization href=#initialization>Initialization</a><li><a aria-label="Shard Contribution" href=#shard-contribution>Shard Contribution</a><li><a aria-label="Shard Validation" href=#shard-validation>Shard Validation</a> <ul><li><a aria-label=computeFinalKey href=#computefinalkey>computeFinalKey</a><li><a aria-label=computeShares href=#computeshares>computeShares</a><li><a aria-label=setInternalShard href=#setinternalshard>setInternalShard</a><li><a aria-label=sanityCheck href=#sanitycheck>sanityCheck</a></ul><li><a aria-label="Deterministic Randomness" href=#deterministic-randomness>Deterministic Randomness</a></ul><li><a aria-label="The Nexus Workflow" href=#the-nexus-workflow>The Nexus Workflow</a> <ul><li><a aria-label="Polling Keepers" href=#polling-keepers>Polling Keepers</a></ul><li><a aria-label="Threat Analysis" href=#threat-analysis>Threat Analysis</a> <ul><li><a aria-label="Key Distribution and Access" href=#key-distribution-and-access>Key Distribution and Access</a> <ul><li><a aria-label="SPIKE Keepers" href=#spike-keepers>SPIKE Keepers</a><li><a aria-label="SPIKE Nexus" href=#spike-nexus>SPIKE Nexus</a></ul><li><a aria-label="Randomness in Shamir’s Secret Sharing" href=#randomness-in-shamir-s-secret-sharing>Randomness in Shamir’s Secret Sharing</a> <ul><li><a aria-label="Entropy Source" href=#entropy-source>Entropy Source</a><li><a aria-label=Independence href=#independence>Independence</a></ul><li><a aria-label="Security Properties" href=#security-properties>Security Properties</a> <ul><li><a aria-label="Access Control" href=#access-control>Access Control</a><li><a aria-label="Key Protection" href=#key-protection>Key Protection</a><li><a aria-label="Compromise Resistance" href=#compromise-resistance>Compromise Resistance</a><li><a aria-label="Secure Connectivity" href=#secure-connectivity>Secure Connectivity</a><li><a aria-label="Shamir’s Secret Sharing" href=#shamir-s-secret-sharing>Shamir’s Secret Sharing</a><li><a aria-label="Zero-Trust Principles" href=#zero-trust-principles>Zero-Trust Principles</a><li><a aria-label="SPIFFE and SPIRE Integration" href=#spiffe-and-spire-integration>SPIFFE and SPIRE Integration</a><li><a aria-label="Additional Security Measures" href=#additional-security-measures>Additional Security Measures</a></ul></ul><li><a aria-label=Conclusion href=#conclusion>Conclusion</a><li><a aria-label="References and Further Reading" href=#references-and-further-reading>References and Further Reading</a> <ul><li><a aria-label=SPIKE href=#spike>SPIKE</a><li><a aria-label="SPIFFE and SPIRE" href=#spiffe-and-spire>SPIFFE and SPIRE</a><li><a aria-label="Security and Cryptography" href=#security-and-cryptography>Security and Cryptography</a></ul></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction</h2><p><strong>Secure secrets management</strong> is a critical aspect of any modern distributed system’s infrastructure. <a href=https://github.com/spiffe/spike><strong>SPIKE</strong></a> (<em>Secure Production Identity for Key Encryption</em>) is a system that achieves secure secrets management through a <strong>distributed</strong>, <strong>zero-trust</strong> architecture.<p>To learn more about <strong>SPIKE</strong>, you can visit<a href=https://spike.ist/><strong>SPIKE</strong>’s website</a> or check out <a href=https://github.com/spiffe/spike><strong>SPIKE</strong>’s GitHub repository</a>.<h2 id=a-video-is-a-worth-a-million-words>A Video is a Worth a Million Words</h2><p>Here is a video that goes over what we discuss in this article:<div style="padding:56.25% 0 0;position:relative"><iframe allow="autoplay; fullscreen; picture-in-picture; clipboard-write" src="https://player.vimeo.com/video/1042946784?badge=0&autopause=0&player_id=0&app_id=58479" title="SPIKE’s Shamir Secrets Sharing with SPIFFE mTLS" frameborder=0 style=width:100%;height:100%;position:absolute;top:0;left:0></iframe></div><script src=https://player.vimeo.com/api/player.js></script><h2 id=keeping-the-root-key-secret>Keeping the Root Key Secret</h2><p>In <strong>SPIKE</strong> architecture, <strong>SPIKE Nexus</strong> is the central secret store. <strong>SPIKE Nexus</strong> requires a <strong>root key</strong> to save its secrets to its <em>backing store</em> in encrypted form. That’s why the <strong>root key</strong> is a critical secret that must always be kept secure.<p>This article discusses how <strong>SPIKE</strong> securely manages the <strong>root key</strong> using <a href=https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing><strong>Shamir’s Secret Sharing</strong></a> scheme.<h2 id=introducing-shamir-s-secret-sharing>Introducing Shamir’s Secret Sharing</h2><p>Our design relies upon several layers of security to ensure the root key remains secure:<ul><li>We leverage <a href=https://spiffe.io/><strong>SPIFFE-based mTLS encryption</strong></a> to secure communication between various <strong>SPIKE</strong> components.<li>We use <a href=https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing><strong>Shamir’s Secret Sharing</strong></a> to split the root key into multiple shares. This ensures that no single entity can access the full key anytime.<li>The Shamir <strong>shares</strong> are never stored on disk.<li><strong>SPIKE Keeper</strong>s generate one share per Keeper; however, a single share is not enough to reconstruct the root key. So even in the unlikely event that a <strong>SPIKE Keeper</strong> is compromised, the root key remains secure.<li>Only <strong>SPIKE Nexus</strong> can compose the root key from the shares; once created, it remains in the memory. The root key is <strong>never</strong> stored on disk and <strong>never</strong> leaves the network perimeter.<li>In addition, there is no API or programmatic access that can reveal the root key. The attacker will need admin privileges and sophisticated memory forensics to extract the root key from the <strong>SPIKE Nexus</strong>, which is a significant security barrier.</ul><p>This article further discusses the architecture and design choices that make <strong>SPIKE</strong>’s <strong>Nexus</strong> and <strong>Keeper</strong> interaction an excellent model for secure key management.<blockquote><p><strong>How about Disaster Recovery?</strong><p>In the case of all <strong>SPIKE Keepers</strong> simultaneously crashing, the root key is lost.<p>We have secure and sophisticated ideas to help teams recover from an unlikely doomsday scenario by requiring multi-party approval to reconstruct the root key. Yet, this is a topic for another article.<p>However, even in this multiple-SPIKE-keepers scenario, a surefire way to prevent from losing the root key is to increase the number of <strong>SPIKE Keeper</strong>s to a higher number, say 5 or 7. This way, even if a few <strong>SPIKE Keeper</strong>s crash, the root key can still be reconstructed.<p>And when you geographically distribute the <strong>SPIKE Keeper</strong>s, you can ensure that even a natural disaster won’t take down all the <strong>SPIKE Keeper</strong>s at once.</blockquote><h2 id=spike-architecture-a-brief-overview>SPIKE Architecture: A Brief Overview</h2><p>The <strong>SPIKE</strong> system consists of three core components:<ul><li><p><strong>SPIKE Keeper</strong>: These are distributed instances responsible for generating shards (<em>parts of a root key</em>) using <a href=https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing>Shamir’s Secret Sharing</a>. Each <strong>SPIKE Keeper</strong> maintains a piece of the secret, ensuring no single entity has the full key.</p><li><p><strong>SPIKE Nexus</strong>: This is the <strong>secrets store</strong> that gathers shards from the <strong>SPIKE Keeper</strong>s to reconstruct the <code>rootKey</code> during bootstrapping, enabling secure initialization of its backing store.</p><li><p><strong>SPIKE Pilot</strong>: This is the CLI tool that communicates with <strong>SPIKE Nexus</strong> and manages policies and secrets through the <strong>SPIKE Nexus RESTful mTLS API</strong>. <strong>SPIKE Pilot</strong> is <strong>not</strong> a part of this article, but it’s an essential component of the <strong>SPIKE</strong> system.</p></ul><p>Both components leverage <a href=https://spiffe.io/><strong>SPIFFE</strong></a> for identity and secure communication through <a href=https://en.wikipedia.org/wiki/Mutual_authentication><strong>mTLS</strong></a>.<h2 id=high-level-design>High-Level Design</h2><p>Here is a high-level overview of the <strong>SPIKE</strong> root key management system. You can open the image in a separate tab for a better view:<div class=z2h-image><p class=img><img alt="SPIKE Root Key Partitioning: High-Level Conceptual Diagram" src=/images/2024/spike/shamir/spike-shamir.jpg><p class=alt style=text-align:center;margin-top:-1.125em;font-size:1em;font-style:italic>SPIKE Root Key Partitioning: High-Level Conceptual Diagram</div><p>This diagram illustrates the the distributed key management system workflow between <strong>SPIKE Keeper</strong>s and the <strong>SPIKE Nexus</strong>. Let me break down the sequence:<p>For starters, all connections use <a href=https://spiffe.io/><strong>SPIFFE</strong> mTLS</a> for security.<h3 id=starting-spike-keepers-and-spike-nexus>Starting SPIKE Keepers and SPIKE Nexus</h3><p>For <strong>SPIKE Keepers</strong> to know about each other and <strong>SPIKE Nexus</strong>, we pass some configuration information during startup using environment variables as follows:<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#928374;font-style:italic># ./hack/start-nexus.sh
</span><span>
</span><span style=color:#fdf4c1>SPIKE_KEEPER_PEERS</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>'{"1":"https://localhost:8443", \
</span><span style=color:#b8bb26>"2":"https://localhost:8543","3":"https://localhost:8643"}' </span><span>\
</span><span style=color:#fdf4c1>./nexus
</span></code></pre><p>Here is how each of the keepers start:<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#928374;font-style:italic># /hack/start-keeper-1.sh
</span><span>
</span><span style=color:#fdf4c1>SPIKE_KEEPER_PEERS</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>'{"1":"https://localhost:8443", \
</span><span style=color:#b8bb26>"2":"https://localhost:8543","3":"https://localhost:8643"}' </span><span>\
</span><span style=color:#fdf4c1>SPIKE_KEEPER_TLS_PORT</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>':8443' </span><span>\
</span><span style=color:#fdf4c1>SPIKE_KEEPER_ID</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>"1" </span><span>\
</span><span style=color:#fdf4c1>./keeper
</span></code></pre><pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#928374;font-style:italic># /hack/start-keeper-2.sh
</span><span>
</span><span style=color:#fdf4c1>SPIKE_KEEPER_PEERS</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>'{"1":"https://localhost:8443",\
</span><span style=color:#b8bb26>"2":"https://localhost:8543","3":"https://localhost:8643"}' </span><span>\
</span><span style=color:#fdf4c1>SPIKE_KEEPER_TLS_PORT</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>':8543' </span><span>\
</span><span style=color:#fdf4c1>SPIKE_KEEPER_ID</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>"2" </span><span>\
</span><span style=color:#fdf4c1>./keeper
</span></code></pre><pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#928374;font-style:italic># /hack/start-keeper-3.sh
</span><span>
</span><span style=color:#fdf4c1>SPIKE_KEEPER_PEERS</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>'{"1":"https://localhost:8443",\
</span><span style=color:#b8bb26>"2":"https://localhost:8543","3":"https://localhost:8643"}' </span><span>\
</span><span style=color:#fdf4c1>SPIKE_KEEPER_TLS_PORT</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>':8643' </span><span>\
</span><span style=color:#fdf4c1>SPIKE_KEEPER_ID</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>"3" </span><span>\
</span><span style=color:#fdf4c1>./keeper
</span></code></pre><h3 id=initial-share-generation-the-top-of-the-diagram>Initial Share Generation (<em>the top of the diagram</em>)</h3><p>Each <strong>SPIKE Keeper</strong> computes a secure random share.<p>There’s a parallel process where each <strong>SPIKE Keeper</strong>:<ul><li>Broadcasts its <code>{id, share}</code> to other <strong>SPIKE Keeper</strong>s<li>Receives shares from other peer <strong>SPIKE Keeper</strong>s</ul><h3 id=root-key-generation-middle-left>Root Key Generation (<em>middle-left</em>)</h3><ul><li><strong>SPIKE Keeper</strong> waits until all shards are collected.<li><strong>SPIKE Keeper</strong> computes a <code>rootKey</code> by <code>XOR</code>ing all collected shards.<li>This ensures that no single <strong>SPIKE Keeper</strong> knows the complete key once it computes its <strong>Shamir Secret Share</strong> from the <code>rootKey</code> and discards the root key and any intermediate values.</ul><h3 id=shamir-secret-sharing>Shamir Secret Sharing</h3><ul><li>Takes the rootKey as input<li>Creates three partitions <ul><li>This will be configurable, but it’s hard-coded to 3 and 2 for now.</ul><li>Uses <code>threshold = 2</code> (<em>meaning any two shares can reconstruct the <code>rootKey</code></em>)</ul><p>Each <strong>SPIKE Keeper</strong> then:<ul><li>Discards the original root key (<em>security measure</em>)<li>Keeps only its assigned partition (<em>also a security measure</em>)<li>Discards knowledge of other partitions</ul><p>Here is a more detailed drill-down of the <strong>SPIKE Keeper</strong> workflow:<ul><li><strong>Compute Secure Random Share</strong>: Each <strong>SPIKE Keeper</strong> generates a cryptographically secure random share derived from an <a href=https://en.wikipedia.org/wiki/Advanced_Encryption_Standard>AES-256</a> seed.<li><strong>Broadcast and Receive</strong>: <strong>SPIKE Keeper</strong>s broadcast their shards (<em>id, share</em>) to peers and receive shards from them in parallel. Secure <a href=https://en.wikipedia.org/wiki/Mutual_authentication><strong>mTLS</strong></a> ensures the <strong>integrity</strong> and <strong>confidentiality</strong> of these communications.<li><strong>Shard Aggregation and Root Key Derivation</strong>: <strong>SPIKE Keeper</strong> waits until all shards are gathered, combines them using <a href=https://en.wikipedia.org/wiki/XOR_cipher><code>XOR</code></a>, and derives the <code>rootKey</code>.<li><strong>Shamir Secret Sharing</strong>: The derived <code>rootKey</code> is split into <strong>three partitions</strong>, ensuring only a subset (<em>e.g., 2 out of 3</em>) is required for reconstruction. <strong>SPIKE Keeper</strong>s discard the <code>rootKey</code> and retain only their assigned share after generating the shares.</ul><h3 id=spike-nexus-bootstrapping-bottom>SPIKE Nexus Bootstrapping (bottom)</h3><p>During startup, <strong>SPIKE Nexus</strong> fetches <strong>exactly two shards</strong> (<em>and no more</em>) from its <strong>SPIKE Keeper</strong> peers. Again, we use <strong>SPIFFE mTLS</strong> for secure communication.<p>In the “<em>reconstruct</em>” phase (bottom-right):<ul><li><strong>SPIKE Nexus</strong> combines the two collected shards.<li>It uses <a href=https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing><em>Shamir Secret Recovery</em></a> to reconstruct the <code>rootKey</code>.<li>It uses the reconstructed key to configure the backing store encryption.</ul><p>Again, here is a more detailed drill-down of this workflow:<ul><li><strong>Acquire Shards</strong>: <strong>SPIKE Nexus</strong> gathers <strong>exactly two shards</strong> from <strong>SPIKE Keeper</strong>s during the bootstrap phase. This is achieved through authenticated requests over <a href=https://spiffe.io/><strong>SPIFFE mTLS</strong></a> connections.<li><strong>Reconstruction</strong>: <strong>SPIKE Nexus</strong> uses <a href=https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing>Shamir’s Secret Sharing Algorithm</a> to reconstruct the <code>rootKey</code> from the collected shards.<li><strong>Configure Backing Store</strong>: The reconstructed <code>rootKey</code> initializes the backing store, securing it for further operations.</ul><p>The following sections will dive deeper into the <strong>SPIKE Keeper</strong> and <strong>SPIKE Nexus</strong> workflows.<h2 id=the-spike-keeper-workflow>The SPIKE Keeper Workflow</h2><h3 id=initialization>Initialization</h3><p>Each <strong>SPIKE Keeper</strong> generates a random <strong>shard</strong> using a cryptographically secure seed. Shards are distributed to other <strong>SPIKE Keeper</strong>s using <a href=https://spiffe.io/><strong>SPIFFE mTLS</strong></a> connections.<p>The following code snippet illustrates the initialization logic:<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>RandomContribution</span><span>() []</span><span style=color:#fabd2f>byte </span><span>{
</span><span>	</span><span style=color:#fdf4c1>myContributionLock</span><span>.</span><span style=color:#fdf4c1>Lock</span><span>()
</span><span>	</span><span style=color:#fa5c4b>defer </span><span style=color:#fdf4c1>myContributionLock</span><span>.</span><span style=color:#fdf4c1>Unlock</span><span>()
</span><span>
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>myContribution</span><span>) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0 </span><span>{
</span><span>		</span><span style=color:#fdf4c1>mySeed</span><span>, </span><span style=color:#fdf4c1>_ </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>crypto</span><span>.</span><span style=color:#fdf4c1>Aes256Seed</span><span>()
</span><span>		</span><span style=color:#fdf4c1>myContribution </span><span style=color:#fe8019>= </span><span>[]</span><span style=color:#fabd2f>byte</span><span>(</span><span style=color:#fdf4c1>mySeed</span><span>)
</span><span>
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>myContribution
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>myContribution
</span><span>}
</span></code></pre><h3 id=shard-contribution>Shard Contribution</h3><p><strong>SPIKE Keeper</strong>s exchange shards with peers using authenticated requests. The contribution process involves generating a random shard and sending it to other <strong>SPIKE Keeper</strong>s.<p>We use <a href=https://github.com/cloudflare/circl>Cloudflare’s CIRCL library</a> for secret sharing. <strong>CIRCL</strong> is a well-maintained, audited, and production-ready library that provides efficient and secure secret sharing capabilities.<p>Here is an example of shard contribution logic:<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>Contribute</span><span>(</span><span style=color:#fdf4c1>source </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>workloadapi</span><span>.</span><span style=color:#fa5c4b>X509Source</span><span>) {
</span><span>	</span><span style=color:#fdf4c1>peers </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>env</span><span>.</span><span style=color:#fdf4c1>Peers</span><span>()
</span><span>	</span><span style=color:#fdf4c1>myId </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>env</span><span>.</span><span style=color:#fdf4c1>KeeperId</span><span>()
</span><span>
</span><span>	</span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>id</span><span>, </span><span style=color:#fdf4c1>peer </span><span style=color:#fe8019>:= </span><span style=color:#fa5c4b>range </span><span style=color:#fdf4c1>peers </span><span>{
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>id </span><span style=color:#fe8019>== </span><span style=color:#fdf4c1>myId </span><span>{
</span><span>			</span><span style=color:#fa5c4b>continue
</span><span>		}
</span><span>
</span><span>		</span><span style=color:#fdf4c1>contributeUrl</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>url</span><span>.</span><span style=color:#fdf4c1>JoinPath</span><span>(
</span><span>			</span><span style=color:#fdf4c1>peer</span><span>, </span><span style=color:#b8bb26>"v1/store/contribute"</span><span>,
</span><span>		)
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>			</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>FatalLn</span><span>(</span><span style=color:#b8bb26>"Failed to join path: " </span><span style=color:#fe8019>+ 
</span><span>				</span><span style=color:#fdf4c1>err</span><span>.</span><span style=color:#fdf4c1>Error</span><span>())
</span><span> 		}
</span><span>
</span><span>		</span><span style=color:#fdf4c1>client</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>net</span><span>.</span><span style=color:#fdf4c1>CreateMtlsClientWithPredicate</span><span>(
</span><span>			</span><span style=color:#fdf4c1>source</span><span>, </span><span style=color:#fdf4c1>auth</span><span>.</span><span style=color:#fdf4c1>IsKeeper</span><span>,
</span><span>		)
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>			</span><span style=color:#fabd2f>panic</span><span>(</span><span style=color:#fdf4c1>err</span><span>)
</span><span>		}
</span><span>
</span><span>		</span><span style=color:#fdf4c1>contribution </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>state</span><span>.</span><span style=color:#fdf4c1>RandomContribution</span><span>()
</span><span>		</span><span style=color:#fdf4c1>state</span><span>.</span><span style=color:#fdf4c1>Shards</span><span>.</span><span style=color:#fdf4c1>Store</span><span>(</span><span style=color:#fdf4c1>myId</span><span>, </span><span style=color:#fdf4c1>contribution</span><span>)
</span><span>
</span><span>		</span><span style=color:#fdf4c1>md</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>json</span><span>.</span><span style=color:#fdf4c1>Marshal</span><span>(</span><span style=color:#fdf4c1>reqres</span><span>.</span><span style=color:#fdf4c1>ShardContributionRequest</span><span>{
</span><span>			</span><span style=color:#fdf4c1>KeeperId</span><span>: </span><span style=color:#fdf4c1>myId</span><span>,
</span><span>			</span><span style=color:#fdf4c1>Shard</span><span>:    </span><span style=color:#fdf4c1>base64</span><span>.</span><span style=color:#fdf4c1>StdEncoding</span><span>.</span><span style=color:#fdf4c1>EncodeToString</span><span>(
</span><span>				</span><span style=color:#fdf4c1>contribution</span><span>),
</span><span>		})
</span><span>
</span><span>		</span><span style=color:#fdf4c1>_</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>net</span><span>.</span><span style=color:#fdf4c1>Post</span><span>(</span><span style=color:#fdf4c1>client</span><span>, </span><span style=color:#fdf4c1>contributeUrl</span><span>, </span><span style=color:#fdf4c1>md</span><span>)
</span><span>		</span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>			</span><span style=color:#fdf4c1>time</span><span>.</span><span style=color:#fdf4c1>Sleep</span><span>(</span><span style=color:#d3869b>5 </span><span style=color:#fe8019>* </span><span style=color:#fdf4c1>time</span><span>.</span><span style=color:#fdf4c1>Second</span><span>)
</span><span>			</span><span style=color:#fdf4c1>_</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>net</span><span>.</span><span style=color:#fdf4c1>Post</span><span>(</span><span style=color:#fdf4c1>client</span><span>, </span><span style=color:#fdf4c1>contributeUrl</span><span>, </span><span style=color:#fdf4c1>md</span><span>)
</span><span>		}
</span><span>	}
</span><span>}
</span></code></pre><h3 id=shard-validation>Shard Validation</h3><p>Once enough shards are collected, <strong>SPIKE Keeper</strong> computes the final <code>rootKey</code>.<p>After this, it computes <strong>Shamir Shares</strong> and discards the <code>rootKey</code>.<p>After that, it also discards all but one of the <strong>Shamir Shares</strong> it computed and retains only the one assigned to it.<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>WaitForShards</span><span>() {
</span><span>	</span><span style=color:#fa5c4b>for </span><span>{
</span><span>		</span><span style=color:#fdf4c1>shardCount </span><span style=color:#fe8019>:= </span><span style=color:#d3869b>0
</span><span>		</span><span style=color:#fdf4c1>Shards</span><span>.</span><span style=color:#fdf4c1>Range</span><span>(</span><span style=color:#fa5c4b>func</span><span>(</span><span style=color:#fdf4c1>key</span><span>, </span><span style=color:#fdf4c1>value </span><span style=color:#fa5c4b>any</span><span>) </span><span style=color:#fabd2f>bool </span><span>{
</span><span>			</span><span style=color:#fdf4c1>shardCount</span><span style=color:#fe8019>++
</span><span>			</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>true
</span><span>		})
</span><span>
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>shardCount </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>3 </span><span>{
</span><span>			</span><span style=color:#fdf4c1>time</span><span>.</span><span style=color:#fdf4c1>Sleep</span><span>(</span><span style=color:#d3869b>2 </span><span style=color:#fe8019>* </span><span style=color:#fdf4c1>time</span><span>.</span><span style=color:#fdf4c1>Second</span><span>)
</span><span>			</span><span style=color:#fa5c4b>continue
</span><span>		}
</span><span>
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>shardCount </span><span style=color:#fe8019>> </span><span style=color:#d3869b>3 </span><span>{
</span><span>			</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>FatalLn</span><span>(</span><span style=color:#b8bb26>"too many shards"</span><span>)
</span><span>		}
</span><span>
</span><span>		</span><span style=color:#928374;font-style:italic>// Compute the final key.
</span><span>		</span><span style=color:#fdf4c1>finalKey </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>computeFinalKey</span><span>()
</span><span>		
</span><span>		</span><span style=color:#928374;font-style:italic>// Compute the Shamir shares off of the final key.
</span><span>		</span><span style=color:#fdf4c1>secret</span><span>, </span><span style=color:#fdf4c1>shares </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>computeShares</span><span>(</span><span style=color:#fdf4c1>finalKey</span><span>)
</span><span>		
</span><span>		</span><span style=color:#928374;font-style:italic>// Save only one shard from the shares and
</span><span>		</span><span style=color:#928374;font-style:italic>// discard everything else
</span><span>		</span><span style=color:#fdf4c1>setInternalShard</span><span>(</span><span style=color:#fdf4c1>shares</span><span>)
</span><span>		
</span><span>		</span><span style=color:#928374;font-style:italic>// Self-consistency check to ensure that
</span><span>		</span><span style=color:#928374;font-style:italic>// the reconstructed secret will match
</span><span>		</span><span style=color:#928374;font-style:italic>// the original secret.
</span><span>		</span><span style=color:#fdf4c1>sanityCheck</span><span>(</span><span style=color:#fdf4c1>secret</span><span>, </span><span style=color:#fdf4c1>shares</span><span>)
</span><span>
</span><span>		</span><span style=color:#fa5c4b>break
</span><span>	}
</span><span>}
</span></code></pre><p>To create shares from the root key, we use <a href=https://github.com/cloudflare/circl>Cloudflare’s CIRCL library</a>.<p>Here are the <code>computeFinalKey</code>, <code>computeShares</code>, <code>setInternalShard</code>, and <code>sanityCheck</code> functions for the sake of completeness:<h4 id=computefinalkey>computeFinalKey</h4><pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>computeFinalKey</span><span>() []</span><span style=color:#fabd2f>byte </span><span>{
</span><span>	</span><span style=color:#fdf4c1>finalKey </span><span style=color:#fe8019>:= </span><span style=color:#fabd2f>make</span><span>([]</span><span style=color:#fabd2f>byte</span><span>, </span><span style=color:#d3869b>32</span><span>)
</span><span>
</span><span>	</span><span style=color:#fdf4c1>counter </span><span style=color:#fe8019>:= </span><span style=color:#d3869b>0
</span><span>	</span><span style=color:#fdf4c1>Shards</span><span>.</span><span style=color:#fdf4c1>Range</span><span>(</span><span style=color:#fa5c4b>func</span><span>(</span><span style=color:#fdf4c1>key</span><span>, </span><span style=color:#fdf4c1>value </span><span style=color:#fa5c4b>any</span><span>) </span><span style=color:#fabd2f>bool </span><span>{
</span><span>		</span><span style=color:#fdf4c1>counter</span><span style=color:#fe8019>++
</span><span>		</span><span style=color:#fdf4c1>shard </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>value</span><span>.([]</span><span style=color:#fabd2f>byte</span><span>)
</span><span>		</span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>:= </span><span style=color:#d3869b>0</span><span>; </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>32</span><span>; </span><span style=color:#fdf4c1>i</span><span style=color:#fe8019>++ </span><span>{
</span><span>			</span><span style=color:#fdf4c1>finalKey</span><span>[</span><span style=color:#fdf4c1>i</span><span>] </span><span style=color:#fe8019>^= </span><span style=color:#fdf4c1>shard</span><span>[</span><span style=color:#fdf4c1>i</span><span>]
</span><span>		}
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>true
</span><span>	})
</span><span>
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>counter </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>3 </span><span>{
</span><span>		</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>FatalLn</span><span>(</span><span style=color:#b8bb26>"computeFinalKey: Not all shards received"</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>finalKey</span><span>) </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>32 </span><span>{
</span><span>		</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>FatalLn</span><span>(</span><span style=color:#b8bb26>"computeFinalKey: key size mismatch"</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>finalKey
</span><span>}
</span></code></pre><h4 id=computeshares>computeShares</h4><pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>computeShares</span><span>(</span><span style=color:#fdf4c1>finalKey </span><span>[]</span><span style=color:#fabd2f>byte</span><span>) (
</span><span>    </span><span style=color:#fdf4c1>group</span><span>.</span><span style=color:#fa5c4b>Scalar</span><span>, []</span><span style=color:#fdf4c1>secretsharing</span><span>.</span><span style=color:#fa5c4b>Share</span><span>,
</span><span>) {
</span><span>	</span><span style=color:#928374;font-style:italic>// Initialize parameters
</span><span>	</span><span style=color:#fdf4c1>g </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>group</span><span>.</span><span style=color:#fdf4c1>P256
</span><span>	</span><span style=color:#fdf4c1>t </span><span style=color:#fe8019>:= </span><span style=color:#fabd2f>uint</span><span>(</span><span style=color:#d3869b>1</span><span>) </span><span style=color:#928374;font-style:italic>// Need t+1 shares to reconstruct
</span><span>	</span><span style=color:#fdf4c1>n </span><span style=color:#fe8019>:= </span><span style=color:#fabd2f>uint</span><span>(</span><span style=color:#d3869b>3</span><span>) </span><span style=color:#928374;font-style:italic>// Total number of shares
</span><span>
</span><span>	</span><span style=color:#928374;font-style:italic>// Create secret from your 32 byte key
</span><span>	</span><span style=color:#fdf4c1>secret </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>g</span><span>.</span><span style=color:#fdf4c1>NewScalar</span><span>()
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>secret</span><span>.</span><span style=color:#fdf4c1>UnmarshalBinary</span><span>(</span><span style=color:#fdf4c1>finalKey</span><span>); </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>		</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>FatalLn</span><span>(
</span><span>			</span><span style=color:#fdf4c1>e</span><span style=color:#b8bb26>"computeShares: Failed to unmarshal key: </span><span style=color:#fdf4c1>%v</span><span style=color:#b8bb26>" </span><span style=color:#fe8019>+ 
</span><span>			</span><span style=color:#fdf4c1>eerr</span><span>.</span><span style=color:#fdf4c1>Error</span><span>())
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#928374;font-style:italic>// Create deterministic random source using 
</span><span>	</span><span style=color:#928374;font-style:italic>// the key itself as seed
</span><span>	</span><span style=color:#928374;font-style:italic>// You could use any other seed value for consistency
</span><span>	</span><span style=color:#fdf4c1>deterministicRand </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>crypto</span><span>.</span><span style=color:#fdf4c1>NewDeterministicReader</span><span>(</span><span style=color:#fdf4c1>finalKey</span><span>)
</span><span>
</span><span>	</span><span style=color:#928374;font-style:italic>// Create shares
</span><span>	</span><span style=color:#fdf4c1>ss </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>secretsharing</span><span>.</span><span style=color:#fdf4c1>New</span><span>(</span><span style=color:#fdf4c1>deterministicRand</span><span>, </span><span style=color:#fdf4c1>t</span><span>, </span><span style=color:#fdf4c1>secret</span><span>)
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>secret</span><span>, </span><span style=color:#fdf4c1>ss</span><span>.</span><span style=color:#fdf4c1>Share</span><span>(</span><span style=color:#fdf4c1>n</span><span>)
</span><span>}
</span></code></pre><h4 id=setinternalshard>setInternalShard</h4><pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>setInternalShard</span><span>(</span><span style=color:#fdf4c1>shares </span><span>[]</span><span style=color:#fdf4c1>secretsharing</span><span>.</span><span style=color:#fa5c4b>Share</span><span>) {
</span><span>	</span><span style=color:#928374;font-style:italic>// Sort the keys of env.Peers() alphabetically 
</span><span>	</span><span style=color:#928374;font-style:italic>// for deterministic shard indexing.
</span><span>	</span><span style=color:#fdf4c1>peers </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>env</span><span>.</span><span style=color:#fdf4c1>Peers</span><span>()
</span><span>	</span><span style=color:#fdf4c1>peerKeys </span><span style=color:#fe8019>:= </span><span style=color:#fabd2f>make</span><span>([]</span><span style=color:#fabd2f>string</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>peers</span><span>))
</span><span>	</span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>id </span><span style=color:#fe8019>:= </span><span style=color:#fa5c4b>range </span><span style=color:#fdf4c1>peers </span><span>{
</span><span>		</span><span style=color:#fdf4c1>peerKeys </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>append</span><span>(</span><span style=color:#fdf4c1>peerKeys</span><span>, </span><span style=color:#fdf4c1>id</span><span>)
</span><span>	}
</span><span>	</span><span style=color:#fdf4c1>sort</span><span>.</span><span style=color:#fdf4c1>Strings</span><span>(</span><span style=color:#fdf4c1>peerKeys</span><span>)
</span><span>
</span><span>	</span><span style=color:#fdf4c1>myId </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>env</span><span>.</span><span style=color:#fdf4c1>KeeperId</span><span>()
</span><span>
</span><span>	</span><span style=color:#928374;font-style:italic>// Find the index of the current SPIKE Keeper's ID
</span><span>	</span><span style=color:#fa5c4b>var </span><span style=color:#fdf4c1>myShard </span><span>[]</span><span style=color:#fabd2f>byte
</span><span>	</span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>index</span><span>, </span><span style=color:#fdf4c1>id </span><span style=color:#fe8019>:= </span><span style=color:#fa5c4b>range </span><span style=color:#fdf4c1>peerKeys </span><span>{
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>id </span><span style=color:#fe8019>== </span><span style=color:#fdf4c1>myId </span><span>{
</span><span>			</span><span style=color:#928374;font-style:italic>// Save the shard corresponding to this Keeper
</span><span>			</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>val</span><span>, </span><span style=color:#fdf4c1>ok </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>Shards</span><span>.</span><span style=color:#fdf4c1>Load</span><span>(</span><span style=color:#fdf4c1>myId</span><span>); </span><span style=color:#fdf4c1>ok </span><span>{
</span><span>				</span><span style=color:#fdf4c1>myShard </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>val</span><span>.([]</span><span style=color:#fabd2f>byte</span><span>)
</span><span>				</span><span style=color:#fdf4c1>shareVal</span><span>, </span><span style=color:#fdf4c1>_ </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>shares</span><span>[
</span><span>				    </span><span style=color:#fdf4c1>index</span><span>].</span><span style=color:#fdf4c1>Value</span><span>.</span><span style=color:#fdf4c1>MarshalBinary</span><span>()
</span><span>
</span><span>				</span><span style=color:#fdf4c1>SetShard</span><span>(</span><span style=color:#fdf4c1>shareVal</span><span>)
</span><span>				</span><span style=color:#fdf4c1>EraseIntermediateShards</span><span>()
</span><span>
</span><span>				</span><span style=color:#fa5c4b>break
</span><span>			}
</span><span>		}
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#928374;font-style:italic>// Ensure myShard is stored correctly in the state namespace
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>myShard </span><span style=color:#fe8019>== </span><span style=color:#d3869b>nil </span><span>{
</span><span>		</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>FatalLn</span><span>(</span><span style=color:#b8bb26>"setInternalShard: id not found"</span><span>)
</span><span>	}
</span><span>}
</span></code></pre><h4 id=sanitycheck>sanityCheck</h4><pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>sanityCheck</span><span>(</span><span style=color:#fdf4c1>secret group</span><span>.</span><span style=color:#fa5c4b>Scalar</span><span>, </span><span style=color:#fdf4c1>shares </span><span>[]</span><span style=color:#fdf4c1>secretsharing</span><span>.</span><span style=color:#fa5c4b>Share</span><span>) {
</span><span>	</span><span style=color:#fdf4c1>t </span><span style=color:#fe8019>:= </span><span style=color:#fabd2f>uint</span><span>(</span><span style=color:#d3869b>1</span><span>) </span><span style=color:#928374;font-style:italic>// Need t+1 shares to reconstruct
</span><span>
</span><span>	</span><span style=color:#fdf4c1>reconstructed</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>secretsharing</span><span>.</span><span style=color:#fdf4c1>Recover</span><span>(</span><span style=color:#fdf4c1>t</span><span>, </span><span style=color:#fdf4c1>shares</span><span>[:</span><span style=color:#d3869b>2</span><span>])
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>		</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>FatalLn</span><span>(</span><span style=color:#b8bb26>"computeShares: Failed to recover: " </span><span style=color:#fe8019>+ 
</span><span>			</span><span style=color:#fdf4c1>err</span><span>.</span><span style=color:#fdf4c1>Error</span><span>())
</span><span>	}
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fe8019>!</span><span style=color:#fdf4c1>secret</span><span>.</span><span style=color:#fdf4c1>IsEqual</span><span>(</span><span style=color:#fdf4c1>reconstructed</span><span>) {
</span><span>		</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>FatalLn</span><span>(
</span><span>		    </span><span style=color:#b8bb26>"computeShares: recovery failure"</span><span>,
</span><span>        )
</span><span>	}
</span><span>}
</span></code></pre><h3 id=deterministic-randomness>Deterministic Randomness</h3><p>The astute reader might notice that while computing the shards, we use a deterministic random source, using the key itself as a seed. This is done to keep the shard calculation consistent across all <strong>SPIKE Keeper</strong>s.<p>Here is the relevant code snippet:<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span>	</span><span style=color:#fdf4c1>deterministicRand </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>crypto</span><span>.</span><span style=color:#fdf4c1>NewDeterministicReader</span><span>(</span><span style=color:#fdf4c1>finalKey</span><span>)
</span><span>	</span><span style=color:#fdf4c1>ss </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>secretsharing</span><span>.</span><span style=color:#fdf4c1>New</span><span>(</span><span style=color:#fdf4c1>deterministicRand</span><span>, </span><span style=color:#fdf4c1>t</span><span>, </span><span style=color:#fdf4c1>secret</span><span>)
</span></code></pre><p>And here is how the <code>NewDeterministicReader</code> function looks:<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>DeterministicReader </span><span style=color:#fa5c4b>struct </span><span>{
</span><span>	</span><span style=color:#fdf4c1>data </span><span>[]</span><span style=color:#fabd2f>byte
</span><span>	</span><span style=color:#fdf4c1>pos  </span><span style=color:#fabd2f>int
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>r </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>DeterministicReader</span><span>) </span><span style=color:#8ec07c>Read</span><span>(</span><span style=color:#fdf4c1>p </span><span>[]</span><span style=color:#fabd2f>byte</span><span>) (</span><span style=color:#fdf4c1>n </span><span style=color:#fabd2f>int</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fabd2f>error</span><span>) {
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>r</span><span>.</span><span style=color:#fdf4c1>pos </span><span style=color:#fe8019>>= </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>r</span><span>.</span><span style=color:#fdf4c1>data</span><span>) {
</span><span>		</span><span style=color:#928374;font-style:italic>// Generate more deterministic data if needed
</span><span>		</span><span style=color:#fdf4c1>hash </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>sha256</span><span>.</span><span style=color:#fdf4c1>Sum256</span><span>(</span><span style=color:#fdf4c1>r</span><span>.</span><span style=color:#fdf4c1>data</span><span>)
</span><span>		</span><span style=color:#fdf4c1>r</span><span>.</span><span style=color:#fdf4c1>data </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>hash</span><span>[:]
</span><span>		</span><span style=color:#fdf4c1>r</span><span>.</span><span style=color:#fdf4c1>pos </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0
</span><span>	}
</span><span>	</span><span style=color:#fdf4c1>n </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>copy</span><span>(</span><span style=color:#fdf4c1>p</span><span>, </span><span style=color:#fdf4c1>r</span><span>.</span><span style=color:#fdf4c1>data</span><span>[</span><span style=color:#fdf4c1>r</span><span>.</span><span style=color:#fdf4c1>pos</span><span>:])
</span><span>	</span><span style=color:#fdf4c1>r</span><span>.</span><span style=color:#fdf4c1>pos </span><span style=color:#fe8019>+= </span><span style=color:#fdf4c1>n
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>n</span><span>, </span><span style=color:#d3869b>nil
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>NewDeterministicReader</span><span>(</span><span style=color:#fdf4c1>seed </span><span>[]</span><span style=color:#fabd2f>byte</span><span>) </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>DeterministicReader </span><span>{
</span><span>	</span><span style=color:#fdf4c1>hash </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>sha256</span><span>.</span><span style=color:#fdf4c1>Sum256</span><span>(</span><span style=color:#fdf4c1>seed</span><span>)
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>DeterministicReader</span><span>{
</span><span>		</span><span style=color:#fdf4c1>data</span><span>: </span><span style=color:#fdf4c1>hash</span><span>[:],
</span><span>		</span><span style=color:#fdf4c1>pos</span><span>:  </span><span style=color:#d3869b>0</span><span>,
</span><span>	}
</span><span>}
</span></code></pre><h2 id=the-nexus-workflow>The Nexus Workflow</h2><h3 id=polling-keepers>Polling Keepers</h3><p><strong>SPIKE Nexus</strong> queries Keepers for shards using mTLS:<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>Tick</span><span>(</span><span style=color:#fdf4c1>ctx context</span><span>.</span><span style=color:#fa5c4b>Context</span><span>, 
</span><span>  </span><span style=color:#fdf4c1>source </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>workloadapi</span><span>.</span><span style=color:#fa5c4b>X509Source</span><span>, </span><span style=color:#fdf4c1>ticker </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>time</span><span>.</span><span style=color:#fa5c4b>Ticker</span><span>) {
</span><span>	</span><span style=color:#fa5c4b>for </span><span>{
</span><span>		</span><span style=color:#fa5c4b>select </span><span>{
</span><span>		</span><span style=color:#fa5c4b>case </span><span style=color:#fe8019>&lt;-</span><span style=color:#fdf4c1>ticker</span><span>.</span><span style=color:#fdf4c1>C</span><span>:
</span><span>			</span><span style=color:#fdf4c1>keepers </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>env</span><span>.</span><span style=color:#fdf4c1>Peers</span><span>()
</span><span>			</span><span style=color:#fdf4c1>shardsCollected </span><span style=color:#fe8019>:= </span><span>[][]</span><span style=color:#fabd2f>byte</span><span>{}
</span><span>
</span><span>			</span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>_</span><span>, </span><span style=color:#fdf4c1>keeperApiRoot </span><span style=color:#fe8019>:= </span><span style=color:#fa5c4b>range </span><span style=color:#fdf4c1>keepers </span><span>{
</span><span>				</span><span style=color:#fdf4c1>u</span><span>, </span><span style=color:#fdf4c1>_ </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>url</span><span>.</span><span style=color:#fdf4c1>JoinPath</span><span>(</span><span style=color:#fdf4c1>keeperApiRoot</span><span>, 
</span><span>					</span><span style=color:#b8bb26>"/v1/store/shard"</span><span>)
</span><span>
</span><span>            </span><span style=color:#fdf4c1>client</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:=</span><span> \
</span><span>                </span><span style=color:#fdf4c1>net</span><span>.</span><span style=color:#fdf4c1>CreateMtlsClientWithPredicate</span><span>(
</span><span>              </span><span style=color:#fdf4c1>source</span><span>, </span><span style=color:#fdf4c1>auth</span><span>.</span><span style=color:#fdf4c1>IsKeeper</span><span>)
</span><span>            </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>                </span><span style=color:#fa5c4b>continue
</span><span>            }
</span><span>
</span><span>            </span><span style=color:#fdf4c1>md</span><span>, </span><span style=color:#fdf4c1>_ </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>json</span><span>.</span><span style=color:#fdf4c1>Marshal</span><span>(</span><span style=color:#fdf4c1>reqres</span><span>.</span><span style=color:#fdf4c1>ShardRequest</span><span>{})
</span><span>            </span><span style=color:#fdf4c1>data</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>net</span><span>.</span><span style=color:#fdf4c1>Post</span><span>(</span><span style=color:#fdf4c1>client</span><span>, </span><span style=color:#fdf4c1>u</span><span>, </span><span style=color:#fdf4c1>md</span><span>)
</span><span>
</span><span>            </span><span style=color:#fa5c4b>var </span><span style=color:#fdf4c1>res reqres</span><span>.</span><span style=color:#fa5c4b>ShardResponse
</span><span>            </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>json</span><span>.</span><span style=color:#fdf4c1>Unmarshal</span><span>(</span><span style=color:#fdf4c1>data</span><span>, </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>res</span><span>); </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>== </span><span style=color:#d3869b>nil </span><span>{
</span><span>                </span><span style=color:#fdf4c1>shard</span><span>, </span><span style=color:#fdf4c1>_ </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>base64</span><span>. \
</span><span>                    </span><span style=color:#fdf4c1>StdEncoding</span><span>.</span><span style=color:#fdf4c1>DecodeString</span><span>(</span><span style=color:#fdf4c1>res</span><span>.</span><span style=color:#fdf4c1>Shard</span><span>)
</span><span>                </span><span style=color:#fdf4c1>shardsCollected </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>append</span><span>(
</span><span>                    </span><span style=color:#fdf4c1>shardsCollected</span><span>, </span><span style=color:#fdf4c1>shard</span><span>,
</span><span>                )
</span><span>            }
</span><span>			}
</span><span>
</span><span>			</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>shardsCollected</span><span>) </span><span style=color:#fe8019>>= </span><span style=color:#d3869b>2 </span><span>{
</span><span>            </span><span style=color:#fdf4c1>reconstructed</span><span>, </span><span style=color:#fdf4c1>_ </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>secretsharing</span><span>.</span><span style=color:#fdf4c1>Recover</span><span>(
</span><span>              </span><span style=color:#d3869b>1</span><span>, </span><span style=color:#fdf4c1>shardsCollected</span><span>[:</span><span style=color:#d3869b>2</span><span>])
</span><span>            </span><span style=color:#fdf4c1>binaryRec</span><span>, </span><span style=color:#fdf4c1>_ </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>reconstructed</span><span>.</span><span style=color:#fdf4c1>MarshalBinary</span><span>()
</span><span>            </span><span style=color:#fdf4c1>state</span><span>.</span><span style=color:#fdf4c1>Initialize</span><span>(</span><span style=color:#fabd2f>string</span><span>(</span><span style=color:#fdf4c1>binaryRec</span><span>))
</span><span>            </span><span style=color:#fa5c4b>return
</span><span>			}
</span><span>		</span><span style=color:#fa5c4b>case </span><span style=color:#fe8019>&lt;-</span><span style=color:#fdf4c1>ctx</span><span>.</span><span style=color:#fdf4c1>Done</span><span>():
</span><span>			</span><span style=color:#fa5c4b>return
</span><span>		}
</span><span>	}
</span><span>}
</span></code></pre><p>To reconstruct the secrets, we, again use <a href=https://github.com/cloudflare/circl>Cloudflare’s CIRCL library</a>.<p>Here is how the <code>state.Initialize()</code> and other related functions look, for completeness:<p>Here is the <code>state.Initialize()</code> function:<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>Initialize</span><span>(</span><span style=color:#fdf4c1>r </span><span style=color:#fabd2f>string</span><span>) {
</span><span>	</span><span style=color:#928374;font-style:italic>// No need for a lock; this method is called only 
</span><span>	</span><span style=color:#928374;font-style:italic>// once during initial bootstrapping.
</span><span>
</span><span>	</span><span style=color:#fdf4c1>persist</span><span>.</span><span style=color:#fdf4c1>InitializeBackend</span><span>(</span><span style=color:#fdf4c1>r</span><span>)
</span><span>}
</span></code></pre><p>And here is the <code>persist.InitializeBackend()</code> function:<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>InitializeBackend</span><span>(</span><span style=color:#fdf4c1>rootKey </span><span style=color:#fabd2f>string</span><span>) </span><span style=color:#fdf4c1>backend</span><span>.</span><span style=color:#fa5c4b>Backend </span><span>{
</span><span>	</span><span style=color:#fdf4c1>backendMu</span><span>.</span><span style=color:#fdf4c1>Lock</span><span>()
</span><span>	</span><span style=color:#fa5c4b>defer </span><span style=color:#fdf4c1>backendMu</span><span>.</span><span style=color:#fdf4c1>Unlock</span><span>()
</span><span>
</span><span>	</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Log</span><span>().</span><span style=color:#fdf4c1>Info</span><span>(
</span><span>		</span><span style=color:#b8bb26>"initializeBackend"</span><span>,
</span><span>		</span><span style=color:#b8bb26>"msg"</span><span>, </span><span style=color:#b8bb26>"Initializing backend"</span><span>, </span><span style=color:#b8bb26>"storeType"</span><span>, 
</span><span>			</span><span style=color:#fdf4c1>env</span><span>.</span><span style=color:#fdf4c1>BackendStoreType</span><span>(),
</span><span>	)
</span><span>
</span><span>	</span><span style=color:#fdf4c1>storeType </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>env</span><span>.</span><span style=color:#fdf4c1>BackendStoreType</span><span>()
</span><span>
</span><span>	</span><span style=color:#fa5c4b>switch </span><span style=color:#fdf4c1>storeType </span><span>{
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>env</span><span>.</span><span style=color:#fdf4c1>Memory</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>memory</span><span>.</span><span style=color:#fdf4c1>NoopStore</span><span>{}
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>env</span><span>.</span><span style=color:#fdf4c1>Sqlite</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>InitializeSqliteBackend</span><span>(</span><span style=color:#fdf4c1>rootKey</span><span>)
</span><span>	</span><span style=color:#fa5c4b>default</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>memory</span><span>.</span><span style=color:#fdf4c1>NoopStore</span><span>{}
</span><span>	}
</span><span>}
</span></code></pre><h2 id=threat-analysis>Threat Analysis</h2><p>This system implements a sophisticated approach to root key management with several layers of security:<h3 id=key-distribution-and-access>Key Distribution and Access</h3><h4 id=spike-keepers>SPIKE Keepers</h4><ul><li>Generate and distribute shares of the root key.<li>Never have access to the complete key except transiently during initialization.<li>After setup, each <strong>SPIKE Keeper</strong> retains only its own Shamir share, which is not enough to reconstruct the root key.<li>All other key material is <strong>securely erased</strong>.</ul><h4 id=spike-nexus>SPIKE Nexus</h4><ul><li>Reconstructs the root key from Shamir shares during initialization<li>Uses the key to configure SQLite (<em>or other backing store</em>) encryption<li>Has no programmatic interface to access the root key<li>The root key exists only in the SQLite driver’s memory space for encryption operations.<li>The root key material is not directly accessible, even through the application code.</ul><h3 id=randomness-in-shamir-s-secret-sharing>Randomness in Shamir’s Secret Sharing</h3><p>At first glance, this might look like a security weakness, but it’s not. Here’s why:<h4 id=entropy-source>Entropy Source</h4><ul><li><code>finalKey</code> is derived from <code>XOR</code>ing multiple 32-byte random contributions<li>If at least one <strong>SPIKE Keeper</strong> provides true randomness, <code>finalKey</code> will be random.<li><code>32 bytes = 256 bits</code> of entropy is cryptographically sufficient<li>Even in the unlikely event that some <strong>SPIKE Keeper</strong>s are malicious, they can’t predict or control the <code>finalKey</code> value as long as one <strong>SPIKE Keeper</strong> is honest.</ul><h4 id=independence>Independence</h4><p>We’re using the same value (<em>i.e., <code>finalKey</code></em>) for both:<ul><li>The secret that gets shared (via scalar conversion)<li>The seed for deterministic randomness in share generation.</ul><p>This coupling is okay because:<ul><li>Shamir Secret Sharing algorithm’s security doesn’t depend on hiding the secret value. In contrast, what matters is the unpredictability of share generation<li><a href=https://github.com/cloudflare/circl><code>CIRCL</code></a>’s implementation uses the deterministic random only for generating polynomial coefficients.The coefficients need to be consistent across keepers but don’t need to be independent from the secret.</ul><p>In <a href=https://github.com/cloudflare/circl>CIRCL’s implementation</a>, the deterministic random is used to generate the polynomial coefficients. The security of <a href=https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing>Shamir’s Secret Sharing</a> relies on the polynomial evaluation, <strong>not</strong> the “<em>security by obscurity</em>” of hiding these coefficients. Therefore, as long as we have sufficient entropy for unique evaluations, the scheme remains secure.<h3 id=security-properties>Security Properties</h3><p>The system provides strong security through:<h4 id=access-control>Access Control</h4><ul><li>Requires multiple <strong>SPIKE Keeper</strong> shares for key reconstruction<li><a href=https://spiffe.io/><strong>SPIFFE workload attestation</strong></a> ensures only legitimate instances participate mTLS secures all network communication</ul><h4 id=key-protection>Key Protection</h4><ul><li>No component retains the complete key in accessible form <ul><li>The original root key is immediately discarded after sharing<li>Each Keeper only maintains knowledge of its own partition and discards the rest</ul><li>While the key exists in <strong>SPIKE Nexus</strong>’s process memory for backing store operations, accessing it would require: <ul><li>Root privileges on the host system<li>Memory inspection capabilities<li>Ability to locate and extract key material from SQLite driver memory space<li>Sophisticated forensics tools<li>Knowledge of the SQLite encryption algorithm and key derivation process<li>Which makes it highly unlikely to compromise the root key</ul></ul><p>In addition, <strong>SPIKE Nexus</strong> run on a hardened, secure host with strict access controls, audit logging, and monitoring because <strong>SPIKE</strong>’s threat model assumes that once an attacker has access to the host system, the system’s security is already compromised.<p><a href=https://spike.ist/#/architecture/security-model>In <strong>SPIKE</strong>’s security model</a>, the primary trust boundary is at the machine level. Once the machine is compromised, hardening <strong>SPIKE</strong> components will provide diminishing returns. In that regard, physical and OS-level hardening is crucial.<p>In essence, the security model relies on:<ul><li><a href=https://spiffe.io/><strong>SPIFFE workload attestation</strong></a> to ensure only legitimate <strong>SPIKE Nexus</strong> instances can gather shares, and only legitimate <strong>SPIKE Keeper</strong> instances can contribute shares.<li><strong>Network isolation</strong> and <strong>mTLS</strong> to prevent unauthorized access<li>The requirement that an attacker would need to compromise multiple <strong>SPIKE Keeper</strong>s to reconstruct the key independently.<li><strong>SPIKE Keeper</strong>s never maintaining the complete root key except transiently during initialization.<li>Each <strong>SPIKE Keeper</strong> only knowing its own Shamir share after initialization, which is not enough to reconstruct the root key.<li>Or compromise the <strong>SPIKE Nexus</strong> host and gain root access to try extracting the root key from memory using sophisticated forensics tools, searching for the key material in the SQLite driver memory space.</ul><h4 id=compromise-resistance>Compromise Resistance</h4><ul><li>Compromising a single <strong>SPIKE Keeper</strong> yields only one share, which is insufficient to reconstruct the root key.<li>Compromising <strong>SPIKE Nexus</strong> application code doesn’t expose the key.<li>It would require both multiple <strong>SPIKE Keeper</strong> compromises <strong>AND</strong> system-level access to extract key material, which is a very high bar for attackers and is highly unlikely to happen.</ul><h4 id=secure-connectivity>Secure Connectivity</h4><p><a href=https://spiffe.io/>SPIFFE mTLS</a> secures <strong>all communication channels</strong>, ensuring <strong>identity verification</strong> and preventing eavesdropping or tampering.<h4 id=shamir-s-secret-sharing>Shamir’s Secret Sharing</h4><p><a href=https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing>Shamir’s Secret Sharing</a> ensures the <em>root key</em> is divided into multiple <em>shards</em>, with reconstruction requiring a predefined threshold of shards. In <strong>SPIKE</strong>’s implementation:<ul><li>The root key is split into <strong>three</strong> shards (<em>configurable</em>).<li>Reconstruction requires <strong>two out of three</strong> shards (<em>configurable</em>), balancing <strong>redundancy</strong> and <strong>security</strong>.</ul><p>This model ensures that:<ul><li>No single <strong>SPIKE Keeper</strong> can compromise the root key.<li>Even if one <strong>SPIKE Keeper</strong> is compromised, the root key remains secure.</ul><h4 id=zero-trust-principles>Zero-Trust Principles</h4><p>This architecture adheres to the following <strong>zero-trust principles</strong>:<ul><li><strong>Least Privilege</strong>: <strong>SPIKE Keeper</strong>s only manage their shards; they cannot reconstruct the root key. During bootstrapping and disaster recovery, they may require additional shards from their peer <strong>SPIKE Keepers</strong>. However, that will be temporary, and the material will be securely erased once the operation is complete.<li><strong>Boundary Enforcement</strong>: It’s important to highlight that the <strong>root key never leaves the network perimeter</strong>. Only shards cross the network boundary and only through secure <a href=https://en.wikipedia.org/wiki/Mutual_authentication><strong>mTLS</strong></a> connections. Even in the very unlikely case of a connection compromise, the shards are cryptographically secure and useless without the other shards.<li><strong>Identity-Based Access</strong>: <a href=https://spiffe.io/><strong>SPIFFE SVIDs</strong></a> are used to authenticate and authorize all communications.</ul><h4 id=spiffe-and-spire-integration>SPIFFE and SPIRE Integration</h4><p><a href=https://spiffe.io/docs/latest/spire-about/><strong>SPIRE</strong></a> (<em>SPIFFE Runtime Environment</em>) provides <strong>workload attestation</strong> and <strong>identity issuance</strong>. Each <strong>SPIKE Keeper</strong> and <strong>SPIKE Nexus</strong> receive a unique <em>SPIFFE Verifiable Identity Document</em> (<strong>SVID</strong>), enabling:<ul><li>Secure <a href=https://en.wikipedia.org/wiki/Mutual_authentication><strong>mTLS</strong></a> connections between components.<li><strong>Workload identity attestation</strong> to ensure only authorized entities participate in shard management.</ul><h4 id=additional-security-measures>Additional Security Measures</h4><ul><li><strong>Mutual Authentication</strong>: Every interaction between <strong>SPIKE Keeper</strong>s and <strong>SPIKE Nexus</strong> is secured by <strong>mTLS</strong>.<li><strong>Shard Validation</strong>: Shards are validated before use to prevent malicious tampering.<li><strong>Sanity Checks</strong>: Reconstruction includes checks to ensure the recovered secret matches expectations.</ul><h2 id=conclusion>Conclusion</h2><p>The architecture’s zero-trust design ensures that no single <strong>SPIKE Keeper</strong> can compromise the <code>rootKey</code> while also providing threshold-based reconstruction that balances redundancy with strict security.<p>Since the number of keepers and the minimum number of shares required for reconstruction are configurable, this design can be adapted to the user’s risk tolerance and security requirements.<p>Additionally, <a href=https://spiffe.io/><strong>SPIFFE</strong>-based workload attestation</a> and secure <a href=https://en.wikipedia.org/wiki/Mutual_authentication><strong>mTLS</strong></a> communication work together to enhance the overall security posture.<p><strong>SPIKE</strong>’s <strong>Nexus</strong> and <strong>Keeper</strong> architecture exemplifies how modern distributed systems can securely manage secrets without compromising availability or scalability.<p>By leveraging <a href=https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing><strong>Shamir’s Secret Sharing</strong></a>, <a href=https://spiffe.io/><strong>SPIFFE mTLS</strong></a>, and a <strong>zero-trust</strong> design, we ensure that the root key, and, therefore, the secrets, remain protected against a wide range of threats.<p>This approach is secure and pragmatic, offering a scalable solution for managing and sharing sensitive material in any distributed system. So, the content presented here can have applications beyond the use case covered in this article.<h2 id=references-and-further-reading>References and Further Reading</h2><h3 id=spike>SPIKE</h3><ul><li><a href=https://spike.ist/><strong>SPIKE</strong> Website</a><li><a href=https://github.com/spiffe/spike><strong>SPIKE</strong> Source Code</a><li><a href=https://spike.ist/#/architecture/security-model><strong>SPIKE</strong> Security Model</a><li><a href=https://spike.ist/#/presentations/README><strong>SPIKE</strong> Presentations and Demos</a></ul><h3 id=spiffe-and-spire>SPIFFE and SPIRE</h3><ul><li><a href=https://spiffe.io/><strong>SPIFFE</strong></a><li><a href=https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/><strong>SPIFFE</strong> Concepts</a><li><a href=https://spiffe.io/docs/latest/spire-about/><strong>SPIRE</strong></a><li><a href=https://zerotohero.dev/spire/mtls/>mTLS with <strong>SPIRE</strong></a><li><a href=https://zerotohero.dev/spire/spire-rocks/>Setting Up <strong>SPIRE</strong> on <strong>EKS</strong> in Less Than Ten Minutes</a></ul><h3 id=security-and-cryptography>Security and Cryptography</h3><ul><li><a href=https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing>Shamir’s Secret Sharing</a><li><a href=https://github.com/cloudflare/circl>Cloudflare’s CIRCL Library</a><li><a href=https://en.wikipedia.org/wiki/Advanced_Encryption_Standard>Advanced Encryption Standard (AES)</a><li><a href=https://en.wikipedia.org/wiki/Mutual_authentication>Mutual Authentication (mTLS)</a><li><a href=https://en.wikipedia.org/wiki/XOR_cipher>XOR Cipher</a></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zerotohero.dev/tags/spiffe/>spiffe</a><li><a href=https://zerotohero.dev/tags/spire/>spire</a><li><a href=https://zerotohero.dev/tags/spike/>spike</a><li><a href=https://zerotohero.dev/tags/shamir/>shamir</a><li><a href=https://zerotohero.dev/tags/secret-sharing/>secret-sharing</a><li><a href=https://zerotohero.dev/tags/security/>security</a><li><a href=https://zerotohero.dev/tags/encryption/>encryption</a><li><a href=https://zerotohero.dev/tags/mtls/>mtls</a><li><a href=https://zerotohero.dev/tags/system-design/>system-design</a><li><a href=https://zerotohero.dev/tags/key-management/>key-management</a></ul><nav class=paginav></nav></footer></article></main><footer class=footer><span>© <a href=https://zerotohero.dev>Volkan Özçelik</a> and <a href=/vadideki-geyik/team>Team Geyik</a></span><br><br> The content on this website is distributed under a <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en>CC-BY-NC-SA 4.0 license</a>.<br><br><a href=/about/privacy>Privacy Policy</a> | <a href=/about/contact>Contact</a><br><br><br></footer><a aria-label="go to top" title="Go to Top (Alt + G)" accesskey=g class=top-link href=#top id=top-link> <svg viewbox="0 0 12 6" fill=currentColor xmlns=http://www.w3.org/2000/svg><path d="M12 6H0l6-6z"/></svg> </a><script>let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });</script><script>var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };</script><script>document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })</script><script>document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';
        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                var content = codeblock.textContent;
                if(codeblock.firstChild.tagName == 'TABLE') {
                    content = Array(...codeblock.firstChild.getElementsByTagName('span')).map((span) => { return span.textContent; }).join('');
                }
                navigator.clipboard.writeText(content);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            // td containing LineNos
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            // table containing LineNos and code
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            // code blocks not having highlight as parent class
            codeblock.parentNode.appendChild(copybutton);
        }
    });</script>